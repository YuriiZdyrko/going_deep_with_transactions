## Schemaless queries

Useful for:
- updating/inserting many rows at once
- doing custom select (for example for reporting)
- scripts (for example seeding database)

Schemas are mappers.
Ecto schemas are used to map any data source into an Elixir struct.

**TIP:** `inserted_at`/`updated_at` are autogenerated by schemas. So either add defaults in migration, or add timestamps manually.

### Example 1: 
- use Changeset for validation
- use insert_all for insertion

1. Define struct
```elixir
defmodule Registration do
    use Ecto.Schema

    embedded_schema do
        field :first_name
        field :last_name
        field :email
    end

    def to_account(registration) do
        Map.take(registration, [:email])
    end

    def to_profile(%{first_name: first, last_name: last}) do
        %{name: "#{first} #{last}"}
    end
end
```

2. Validate and cast struct
```elixir
fields = [:first_name, :last_name, :email]

changeset =
    %Registration{}
    |> Ecto.Changeset.cast(params["sign_up"], fields)
    |> validate_required(...)
    |> validate_length(...)
```

3. Use insert_all:
```elixir
if changeset.valid? do
    # Get the modified registration struct out of the changeset
    registration = Ecto.Changeset.apply_changes(changeset)

    MyApp.Repo.transaction fn ->
        MyApp.Repo.insert_all 
            "accounts", 
            Registration.to_account(registration)
        MyApp.Repo.insert_all 
            "profiles", 
            Registration.to_profile(registration)
    end

    {:ok, registration}
else
    # Annotate the action we tried to perform so the UI shows errors
    changeset = %{changeset | action: :registration}
    {:error, changeset}
end
```


### Example 2:
See consequences of not relying on shemas:
- need for a custom `select`, as no default `select`, returning schema struct is generated
- need for manual type conversion, as runtime arguments' types are no longer inferred from schema

```elixir
def running_activities(start_at, end_at)
  query =
    from u in "users",
      join: a in "activities",
      on: a.user_id == u.id,
      where:
        a.start_at > type(^start_at, :naive_datetime) and
          a.end_at < type(^end_at, :naive_datetime),
      group_by: a.user_id,
      select: %{
        user_id: a.user_id,
        interval: a.end_at - a.start_at,
        count: count(u.id)
      }

  MyApp.Repo.all(query)
end
```
